# BoardGame/Chess
' created by Leonard Pauli, 7-8 sept 2018

' changes:
	- using initial index 0 instead of common verbal index 1
		eg. for row, rank, etc

' rim:
	(a where b) -> (a | filter b)


' TODO
	allowed moves
		move types definition of available tiles as a function
	move as subtype of action?
	undo functionallity
	player.captured pieces
		score
			use for remi
	game logic
		on start:
			delaUt pieces
			do rounds: round
				do moves
					handle capture?
					handle state change?
					handle en pesant
					handle promotion
	simple NPC
		- random
		- capture if possible
		- prioritise higher score
		- inspect possible reaches of two moves of same piece
			- if possible capture much higher then after just one
				- move to allow it during next move
	time limit per round option
	generate moves sequence string / serialize according to standards
	simple terminal stream based
		- input
			- move {move command}\n // performs move action
			- show // prints board + player scores
	simple terminal interactive
		- like the stream based, but using clear screen + show + prompts for better UI
	specify tests
	setup java project
	setup tests
	implement tests
	implement BoardGame
	implement Chess
	etc
	commit final
	

# Chess

Chess is BoardGame
	rule:
		rounds.repeated.max: 3 // else; force other move or checkmate/remi
		variants:
			- "Chess960" alias "Fischer Random Chess" // https://en.wikipedia.org/wiki/Chess960
				' on start.after:
					// randomize players homeranks with same seed while keeping Bishops on opposite color
				// ... action.castle.allowed with player: true if not done already

	movesPerPlayerAndRound is Int: 1
	players.count.target is Int: 2
	Board.size.(x, y) is Int: 8
	Board.Tile.pieces.count.max is Int: 1
	Round.Move.time.duration.max: 30s
	Round.Move.Movement.Type
		- "diagonal"
		- "left"
		- "right"
		- "up"
		- "down"
		- "l-move" // the horse
		- "castling" // rokad? tower and king?
		- "en-passant" // bonde tar snett
		- "promotion" // bonde konverterar vid kanten
		- "action"
			is Action // TODO: shouldn't movement be an action?

	Round.Move.Movement
		capture is Piece
		value: capture.type.value or 0

	// TODO: automatic type detection probable by name? (ie. player -> is Player (if exists))
	on gameover with player:
		do player.active: false

	State
		- Check // escapable immediate threat for target's king by source
			source is Player
			target is Player
		- Remi
			// alias: Draw
		- Stalemate // player unable to move, but isn't in check or checkmate
		- Checkmate // inescapable immediate threat for target's king by source
			source is Player
			target is Player
			on activated:
				do gameover with target

	Board.Tile
		// alias "Square"
		is underAttack with player: some (player.pieces(.tile isn't self) |> .canAttack self)
		is safe with player: not some (players(active, not player) |> underAttack)
		path{direct, between} with tile: ...
			// self.edges(is direct) ...
		
		color: or position:
			- .row.even is .col.even: black
			- else: white

		position is Position
			row is Int
				rank with player:
					' or player.color:
							- black: board.size.y - 1 - row
							- white: row
							- else: ... // use some specifier on player instead of color?
					is home if is 0 // homerank, usually where non-pawn pieces start
			col is Int
				as String: "A".charCode + self | String.fromCharCode
			file: col as String
			as String // eg. A4

	Board.homerank with player: .tiles where (.position.row.rank with player) is home

	Piece
		canAttack with tile: some (.type.moves.possible.types |> .reaches {tile, startingTile: self})
		color: owner.player.color

	Piece.Type:
		- King
		- Queen
			value: 9
		- Rook
			value: 5
		- Knight
			value: 3
		- Bishop
			value: 3
		- Pawn
			value: 1

	Player
		color is Color
		on resign:
			do gameover with self

	on start:
		do players: 0..players.count.target |> Player
			name: "Player \(.it + 1)"
			color: or .it
				- 0: white
				- 1: black
				- else: Color.random{saturation: 0.5, lightness: 0.5}
			active: true
			pieces:
				' TODO: positions?
					should be mirrored between players
					player.pieces(is Queen).tile.color is player.color
					RKB QK BKR
				- 1 * King
				- 1 * Queen
				- 2 * Rook
				- 2 * Knight
				- 2 * Bishop
				- 8 * Pawn

	Action.Castling
		// treated as a move
		' moves both the king and a rook be:
			- "queenside castling"
				// alias "a-side castling" if Chess960
				king.position: c-file
				rook(a-side): d-file
				move.notation: "0-0-0"
			- "kingside castling"
				// alias "h-side castling" if Chess960
				king.position: g-file
				rook(h-side).position: f-file
				move.notation: "0-0"
		' if Chess960
			supports all the different possible initial positions of king and rook
		prerequisites:
			tilesInbetween:| it.tile.path{direct, between} it.tile.next
			toBeVacant: (tilesInbetween king) + king.tile.next + (tilesInbetween rook) + rook.tile.next
			- (king, castling rook).moves.previously.count: 0
			- all (tilesInbetween king |> .safe with player) // all alias and
			- all (toBeVacant |> .pieces(not (rook or king)) is Empty)
			- player.moves(is Action.Castling).count is 0


# BoardGame

BoardGame
	players is many Player
		name is String
		pieces is many Piece

	rounds is many Round
		moves is many Move
			time{(start, end) is Date, duration is Time}
			player is Player
			piece is Piece
			movement is Movement
				type is Movement.Type
					name is String
					reaches{is Boolean} with {tile, startingTile}
				from is Position or Empty
				to is Position or Empty
				do reverse: ... // for undo

	states is many State

	Player
		name is String
		moves is many Move
		pieces is many Piece
		active is Boolean

	Board
		tiles is many Tile
			edges is many Edge
				tiles is many{2} Tile
				movement.type{is Movement.Type or Empty} with origin{is in tiles}:
					' returns:
						- None if blocked/one directional
						- same if unidirectional
						- else conditional // (eg. pawn in chess cannot move backwards)
			pieces is many Piece
			position is Position
				as String


	Piece
		owner.player is Player
		tile is Tile
		type is Type
			name is String
			moves.possible.types is many Movement.Type
			// moves.possible.types with state: ...
